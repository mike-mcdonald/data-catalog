/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./icons/chevron-down.svg":
/*!********************************!*\
  !*** ./icons/chevron-down.svg ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" class=\\\"fill-current h-6 w-6\\\" viewBox=\\\"0 0 20 20\\\"><path d=\\\"M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z\\\"></path></svg>\"\n\n//# sourceURL=webpack:///./icons/chevron-down.svg?");

/***/ }),

/***/ "./icons/info.svg":
/*!************************!*\
  !*** ./icons/info.svg ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 24 24\\\" fill=\\\"none\\\" stroke=\\\"currentColor\\\" stroke-width=\\\"2\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" class=\\\"stroke-current h-6 w-6 feather feather-info\\\"><circle cx=\\\"12\\\" cy=\\\"12\\\" r=\\\"10\\\"></circle><line x1=\\\"12\\\" y1=\\\"16\\\" x2=\\\"12\\\" y2=\\\"12\\\"></line><line x1=\\\"12\\\" y1=\\\"8\\\" x2=\\\"12\\\" y2=\\\"8\\\"></line></svg>\"\n\n//# sourceURL=webpack:///./icons/info.svg?");

/***/ }),

/***/ "./icons/more-vertical.svg":
/*!*********************************!*\
  !*** ./icons/more-vertical.svg ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 24 24\\\" fill=\\\"none\\\" stroke=\\\"currentColor\\\" stroke-width=\\\"2\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" class=\\\"fill-current stroke-current h-6 w-6 feather feather-more-vertical\\\"><circle cx=\\\"12\\\" cy=\\\"12\\\" r=\\\"1\\\"></circle><circle cx=\\\"12\\\" cy=\\\"5\\\" r=\\\"1\\\"></circle><circle cx=\\\"12\\\" cy=\\\"19\\\" r=\\\"1\\\"></circle></svg>\"\n\n//# sourceURL=webpack:///./icons/more-vertical.svg?");

/***/ }),

/***/ "./icons/move.svg":
/*!************************!*\
  !*** ./icons/move.svg ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 24 24\\\" class=\\\"fill-current stroke-current h-6 w-6\\\" stroke-width=\\\"2\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" class=\\\"feather feather-move\\\"><polyline points=\\\"5 9 2 12 5 15\\\"></polyline><polyline points=\\\"9 5 12 2 15 5\\\"></polyline><polyline points=\\\"15 19 12 22 9 19\\\"></polyline><polyline points=\\\"19 9 22 12 19 15\\\"></polyline><line x1=\\\"2\\\" y1=\\\"12\\\" x2=\\\"22\\\" y2=\\\"12\\\"></line><line x1=\\\"12\\\" y1=\\\"2\\\" x2=\\\"12\\\" y2=\\\"22\\\"></line></svg>\"\n\n//# sourceURL=webpack:///./icons/move.svg?");

/***/ }),

/***/ "./js/src/cshs.es6.js":
/*!****************************!*\
  !*** ./js/src/cshs.es6.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @file\n * Behavior which initializes the simplerSelect jQuery Plugin.\n */\n(function ($) {\n  'use strict';\n\n  Drupal.behaviors.cshs = {\n    attach: function (context, settings) {\n      $('select.simpler-select-root', context).once('cshs').each(function (idx, element) {\n        // See if we got settings from Drupal for this field.\n        if (typeof settings.cshs !== 'undefined' && typeof settings.cshs[element.id] !== 'undefined') {\n          $(element).simplerSelect(settings.cshs[element.id]);\n        }\n      });\n    }\n  };\n})(jQuery);\n\n//# sourceURL=webpack:///./js/src/cshs.es6.js?");

/***/ }),

/***/ "./js/src/dropbutton.es6.js":
/*!**********************************!*\
  !*** ./js/src/dropbutton.es6.js ***!
  \**********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _icons_more_vertical_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../icons/more-vertical.svg */ \"./icons/more-vertical.svg\");\n/* harmony import */ var _icons_more_vertical_svg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_icons_more_vertical_svg__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * @file\n * Dropbutton feature.\n */\n\n\n(function ($, Drupal) {\n  /**\n   * A DropButton presents an HTML list as a button with a primary action.\n   *\n   * All secondary actions beyond the first in the list are presented in a\n   * dropdown list accessible through a toggle arrow associated with the button.\n   *\n   * @constructor Drupal.DropButton\n   *\n   * @param {HTMLElement} dropbutton\n   *   A DOM element.\n   * @param {object} settings\n   *   A list of options including:\n   * @param {string} settings.title\n   *   The text inside the toggle link element. This text is hidden\n   *   from visual UAs.\n   */\n  function DropButton(dropbutton, settings) {\n    // Merge defaults with settings.\n    const options = $.extend({\n      title: Drupal.t('List additional actions')\n    }, settings);\n    const $dropbutton = $(dropbutton);\n    /**\n     * @type {jQuery}\n     */\n\n    this.$dropbutton = $dropbutton;\n    /**\n     * @type {jQuery}\n     */\n\n    this.$list = $dropbutton.find('.dropbutton');\n    /**\n     * Find actions and mark them.\n     *\n     * @type {jQuery}\n     */\n\n    this.$actions = this.$list.find('.dropbutton-action'); // Add the special dropdown only if there are hidden actions.\n\n    if (this.$actions.length > 1) {\n      // Identify the first element of the collection.\n      const $primary = this.$actions.slice(0, 1); // Identify the secondary actions.\n\n      const $secondary = this.$actions.slice(1);\n      $secondary.addClass('secondary-action'); // Add toggle link.\n\n      $primary.append(Drupal.theme('dropbuttonToggle', options)); // Bind mouse events.\n\n      this.$dropbutton.addClass('dropbutton-multiple').on({\n        /**\n         * Adds a timeout to close the dropdown on mouseleave.\n         *\n         * @ignore\n         */\n        'mouseleave.dropbutton': $.proxy(this.hoverOut, this),\n\n        /**\n         * Clears timeout when mouseout of the dropdown.\n         *\n         * @ignore\n         */\n        'mouseenter.dropbutton': $.proxy(this.hoverIn, this),\n\n        /**\n         * Similar to mouseleave/mouseenter, but for keyboard navigation.\n         *\n         * @ignore\n         */\n        'focusout.dropbutton': $.proxy(this.focusOut, this),\n\n        /**\n         * @ignore\n         */\n        'focusin.dropbutton': $.proxy(this.focusIn, this)\n      });\n    } else {\n      this.$dropbutton.addClass('dropbutton-single');\n    }\n  }\n  /**\n   * Delegated callback for opening and closing dropbutton secondary actions.\n   *\n   * @function Drupal.DropButton~dropbuttonClickHandler\n   *\n   * @param {jQuery.Event} e\n   *   The event triggered.\n   */\n\n\n  function dropbuttonClickHandler(e) {\n    e.preventDefault();\n    $(e.target).closest('.dropbutton-wrapper').toggleClass('open');\n  }\n  /**\n   * Process elements with the .dropbutton class on page load.\n   *\n   * @type {Drupal~behavior}\n   *\n   * @prop {Drupal~behaviorAttach} attach\n   *   Attaches dropButton behaviors.\n   */\n\n\n  Drupal.behaviors.dropButton = {\n    attach(context, settings) {\n      const $dropbuttons = $(context).find('.dropbutton-wrapper').once('dropbutton');\n\n      if ($dropbuttons.length) {\n        // Adds the delegated handler that will toggle dropdowns on click.\n        const $body = $('body').once('dropbutton-click');\n\n        if ($body.length) {\n          $body.on('click', '.dropbutton-toggle', dropbuttonClickHandler);\n        } // Initialize all buttons.\n\n\n        const il = $dropbuttons.length;\n\n        for (let i = 0; i < il; i++) {\n          DropButton.dropbuttons.push(new DropButton($dropbuttons[i], settings.dropbutton));\n        }\n      }\n    }\n\n  };\n  /**\n   * Extend the DropButton constructor.\n   */\n\n  $.extend(DropButton,\n  /** @lends Drupal.DropButton */\n  {\n    /**\n     * Store all processed DropButtons.\n     *\n     * @type {Array.<Drupal.DropButton>}\n     */\n    dropbuttons: []\n  });\n  /**\n   * Extend the DropButton prototype.\n   */\n\n  $.extend(DropButton.prototype,\n  /** @lends Drupal.DropButton# */\n  {\n    /**\n     * Toggle the dropbutton open and closed.\n     *\n     * @param {bool} [show]\n     *   Force the dropbutton to open by passing true or to close by\n     *   passing false.\n     */\n    toggle(show) {\n      const isBool = typeof show === 'boolean';\n      show = isBool ? show : !this.$dropbutton.hasClass('open');\n      this.$dropbutton.toggleClass('open', show);\n    },\n\n    /**\n     * @method\n     */\n    hoverIn() {\n      // Clear any previous timer we were using.\n      if (this.timerID) {\n        window.clearTimeout(this.timerID);\n      }\n    },\n\n    /**\n     * @method\n     */\n    hoverOut() {\n      // Wait half a second before closing.\n      this.timerID = window.setTimeout($.proxy(this, 'close'), 500);\n    },\n\n    /**\n     * @method\n     */\n    open() {\n      this.toggle(true);\n    },\n\n    /**\n     * @method\n     */\n    close() {\n      this.toggle(false);\n    },\n\n    /**\n     * @param {jQuery.Event} e\n     *   The event triggered.\n     */\n    focusOut(e) {\n      this.hoverOut.call(this, e);\n    },\n\n    /**\n     * @param {jQuery.Event} e\n     *   The event triggered.\n     */\n    focusIn(e) {\n      this.hoverIn.call(this, e);\n    }\n\n  });\n  $.extend(Drupal.theme,\n  /** @lends Drupal.theme */\n  {\n    /**\n     * A toggle is an interactive element often bound to a click handler.\n     *\n     * @param {object} options\n     *   Options object.\n     * @param {string} [options.title]\n     *   The button text.\n     *\n     * @return {string}\n     *   A string representing a DOM fragment.\n     */\n    dropbuttonToggle(options) {\n      const dropbuttonClasses = ['dropbutton-toggle', 'border-l', 'pl-3', 'flex'];\n      return `<span class=\"${dropbuttonClasses.join(' ')}\">\n          <span class=\"visually-hidden\">${options.title}</span>\n          <button class=\"flex\" type=\"button\">\n            ${_icons_more_vertical_svg__WEBPACK_IMPORTED_MODULE_0___default.a}\n          </button>\n        </span>`;\n    }\n\n  }); // Expose constructor in the public space.\n\n  Drupal.DropButton = DropButton;\n})(jQuery, Drupal);\n\n//# sourceURL=webpack:///./js/src/dropbutton.es6.js?");

/***/ }),

/***/ "./js/src/simpler-select.es6.js":
/*!**************************************!*\
  !*** ./js/src/simpler-select.es6.js ***!
  \**************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _icons_chevron_down_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../icons/chevron-down.svg */ \"./icons/chevron-down.svg\");\n/* harmony import */ var _icons_chevron_down_svg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_icons_chevron_down_svg__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * @file\n * Render standard select with hierarchical options: as set of selects, one for each level of the hierarchy.\n */\n\n\n(function ($, pluginName) {\n  'use strict'; // Create the defaults once.\n\n  var defaults = {\n    noneLabel: '- Please choose -',\n    noneValue: '_none',\n    labels: []\n  }; // The actual plugin constructor.\n\n  function Plugin(element, options) {\n    this.$element = $(element);\n    this.$currentSelect = null;\n    this.settings = $.extend({}, defaults, options);\n    this.selectOptions = [];\n    this.init();\n  }\n\n  Plugin.prototype = {\n    init: function () {\n      var that = this; // Ensure that we'll clearly initiate a new instance.\n\n      that.destroy();\n      that.$element.find('option').each(function () {\n        var $option = $(this);\n        that.selectOptions.push({\n          value: $option.val(),\n          label: $option.text(),\n          parent: $option.data('parent') || 0,\n          children: []\n        });\n      });\n      var tree = that.buildTree(that.selectOptions);\n\n      if (tree === null) {\n        return;\n      }\n\n      var initialValue = that.$element.val();\n      var initialParents = [];\n      var $selectElement = that.createSelect(tree);\n      var $currentSelect = $selectElement;\n\n      if (initialValue) {\n        if (typeof initialValue !== 'string') {\n          // If array, flatten it.\n          initialValue = initialValue.shift();\n        } // Get all parents, starting from the initial value.\n\n\n        initialParents = that.getAllParents(initialValue); // Reverse the parents, that they start from the root.\n\n        initialParents.reverse(); // Add the current value as the last leave.\n\n        initialParents.push(initialValue);\n      }\n\n      this.$element.after($selectElement);\n      $.each(initialParents, function (i, value) {\n        that.selectSetValue($currentSelect, value);\n        var $nextSelect = that.createSelect(that.getOptionInfoByValue(value).children, value, i + 1);\n\n        if (null !== $nextSelect) {\n          $currentSelect.after($nextSelect);\n          $currentSelect = $nextSelect;\n        }\n      }); // Hide the original.\n\n      that.$element.hide();\n    },\n\n    /**\n     * Destroy CSHS.\n     */\n    destroy: function () {\n      this.selectOptions = [];\n      this.$element.show().nextAll('.select-wrapper').remove();\n    },\n\n    /**\n     * Given an array of options, build an HTML select element.\n     *\n     * @param {HTMLElement[]|HTMLOptionElement[]} options\n     *   List of options.\n     * @param {String} [parent]\n     *   Parent option.\n     * @param {Number} [level]\n     *   Nesting level.\n     *\n     * @return {jQuery|null}\n     *   Newly created element.\n     */\n    createSelect: function (options, parent, level) {\n      if (!options || options.length < 1) {\n        return null;\n      }\n\n      parent = parent || this.settings.noneValue;\n      level = level || 0;\n      const wrapperClasses = ['select-wrapper', 'relative'];\n      const chevronClasses = ['pointer-events-none', 'absolute', 'pin-y', 'pin-r', 'flex', 'items-center', 'px-2'];\n      const chevronElement = `\n      <div class=\"${chevronClasses.join(' ')}\">\n      ${_icons_chevron_down_svg__WEBPACK_IMPORTED_MODULE_0___default.a}\n      </div>\n      `;\n      const selectClasses = ['simpler-select', 'w-full'];\n      const selectElement = `<select class=\"${selectClasses.join(' ')}\">`;\n      var that = this;\n      var $select = $(selectElement).addClass(that.$element.attr('class'));\n      var $wrapper = $(`<div class=\"${wrapperClasses.join(' ')}\">`);\n\n      if (that.$element.hasClass('error')) {\n        $select.addClass('error');\n      } // Always add the \"_none\" option.\n\n\n      $select.append('<option value=\"' + that.settings.noneValue + '\" data-parent-value=\"' + parent + '\">' + that.settings.noneLabel + '</option>');\n      $.each(options, function (i, option) {\n        // Do not add \"_none\" option (already added by code above).\n        if (option.value != that.settings.noneValue) {\n          var $option = $('<option>').val(option.value) // Remove dashes from the beginning, then set the label.\n          .text(option.label.replace(/(- )+/, ''));\n\n          if (option.children.length) {\n            $option.addClass('has-children');\n          }\n\n          $select.append($option);\n        }\n      });\n      $select.change(function () {\n        that.$currentSelect = $(this); // Remove deeper selects.\n\n        that.selectRemoveNext(that.$currentSelect); // Get the selected value and also set the original drop-down.\n\n        var $selected = that.$currentSelect.find('option:selected');\n        var selectedValue = $selected.val();\n        var parentValue = $selected.data('parent-value');\n\n        if (undefined === parentValue) {\n          parentValue = selectedValue;\n        }\n\n        that.$element.val(parentValue).change();\n\n        if (selectedValue == that.settings.noneValue) {\n          return;\n        } // Build new child select.\n\n\n        var optionInfo = that.getOptionInfoByValue(selectedValue);\n\n        if (undefined !== optionInfo.children) {\n          that.addSelectAfter(that.createSelect(optionInfo.children, selectedValue, that.selectGetLevel()));\n        }\n      });\n\n      if (that.settings.labels[level]) {\n        $wrapper.append('<label>' + that.settings.labels[level] + '</label>');\n      }\n\n      $wrapper.append($select);\n      $wrapper.append(chevronElement);\n      return $wrapper;\n    },\n\n    /**\n     * Given an flat array an tree is built.\n     *\n     * @param {Object[]} array\n     *   Options list.\n     * @param {Object} [parent]\n     *   Parent option.\n     * @param {Array} [tree]\n     *   Existing options.\n     *\n     * @return {Array}\n     *   Options tree.\n     */\n    buildTree: function (array, parent, tree) {\n      tree = tree || [];\n      parent = parent || {\n        value: 0\n      };\n      var children = $.grep(array, function (child) {\n        // Here must be no strict comparison!\n        return undefined !== child && child.parent == parent.value;\n      });\n\n      if (children.length) {\n        if (0 == parent.value) {\n          tree = children;\n        } else {\n          parent.children = children;\n        }\n\n        for (var i = 0; i < children.length; i++) {\n          this.buildTree(array, children[i], tree);\n        }\n      }\n\n      return tree;\n    },\n\n    /**\n     * Set the value of a select to the given.\n     *\n     * @param {jQuery} $select\n     *   Wrapper element.\n     * @param {String} value\n     *   New value to set.\n     */\n    selectSetValue: function ($select, value) {\n      $select.find('select').val(value);\n    },\n\n    /**\n     * Remove all following selects.\n     */\n    selectRemoveNext: function () {\n      this.$currentSelect.parents('.select-wrapper').nextAll('.select-wrapper').remove();\n    },\n\n    /**\n     * Add a newSelect after the currentSelect.\n     *\n     * @param {jQuery} $newSelect\n     *   New \"select\" element.\n     */\n    addSelectAfter: function ($newSelect) {\n      this.$currentSelect.parents('.select-wrapper').after($newSelect);\n    },\n\n    /**\n     * Get the hierarchy level of given select.\n     *\n     * @return {Number}\n     *   Number of wrappers.\n     */\n    selectGetLevel: function () {\n      return this.$currentSelect.parents('.form-type-cshs').find('.select-wrapper').length;\n    },\n\n    /**\n     * Given a value build an array of all parents (from leave to root).\n     *\n     * @param {String} value\n     *   Value of option.\n     * @param {Array} [parents]\n     *   Parent options.\n     *\n     * @return {Array}\n     *   Updated parent options list.\n     */\n    getAllParents: function (value, parents) {\n      if (value == this.settings.noneValue) {\n        return [];\n      }\n\n      parents = parents || [];\n      var parent = this.getOptionByValue(value).data('parent');\n\n      if (undefined !== parent && 0 != parent) {\n        parents.push(parent);\n        this.getAllParents(this.getOptionByValue(parent).val(), parents);\n      }\n\n      return parents;\n    },\n\n    /**\n     * Tiny helper to get the option jQuery object.\n     *\n     * @param {String} value\n     *   Value of an option.\n     *\n     * @return {jQuery}\n     *   Element.\n     */\n    getOptionByValue: function (value) {\n      return this.$element.find('option[value=\"' + value + '\"]');\n    },\n\n    /**\n     * Helper to get the info-object which corresponds to an option value.\n     *\n     * @param {String} value\n     *   Value of an option.\n     *\n     * @return {Object}\n     *   Element.\n     */\n    getOptionInfoByValue: function (value) {\n      var optionInfo = {};\n      $.each(this.selectOptions, function (idx, option) {\n        if (option.value == value) {\n          optionInfo = option;\n          return false;\n        }\n      });\n      return optionInfo;\n    }\n  }; // A really lightweight plugin wrapper around the constructor,\n  // preventing against multiple instantiations.\n\n  $.fn[pluginName] = function (options) {\n    this.each(function () {\n      if (!$.data(this, 'plugin_' + pluginName)) {\n        $.data(this, 'plugin_' + pluginName, new Plugin(this, options));\n      }\n    });\n    return this;\n  };\n})(jQuery, 'simplerSelect');\n\n//# sourceURL=webpack:///./js/src/simpler-select.es6.js?");

/***/ }),

/***/ "./js/src/tabledrag.es6.js":
/*!*********************************!*\
  !*** ./js/src/tabledrag.es6.js ***!
  \*********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _icons_move_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../icons/move.svg */ \"./icons/move.svg\");\n/* harmony import */ var _icons_move_svg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_icons_move_svg__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _icons_info_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../icons/info.svg */ \"./icons/info.svg\");\n/* harmony import */ var _icons_info_svg__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_icons_info_svg__WEBPACK_IMPORTED_MODULE_1__);\n/**\n * @file\n * Provide dragging capabilities to admin uis.\n */\n\n/**\n * Triggers when weights columns are toggled.\n *\n * @event columnschange\n */\n\n\n\n(function ($, Drupal, drupalSettings) {\n  /**\n   * Store the state of weight columns display for all tables.\n   *\n   * Default value is to hide weight columns.\n   */\n  let showWeight = JSON.parse(localStorage.getItem('Drupal.tableDrag.showWeight'));\n  /**\n   * Drag and drop table rows with field manipulation.\n   *\n   * Using the drupal_attach_tabledrag() function, any table with weights or\n   * parent relationships may be made into draggable tables. Columns containing\n   * a field may optionally be hidden, providing a better user experience.\n   *\n   * Created tableDrag instances may be modified with custom behaviors by\n   * overriding the .onDrag, .onDrop, .row.onSwap, and .row.onIndent methods.\n   * See blocks.js for an example of adding additional functionality to\n   * tableDrag.\n   *\n   * @type {Drupal~behavior}\n   */\n\n  Drupal.behaviors.tableDrag = {\n    attach(context, settings) {\n      function initTableDrag(table, base) {\n        if (table.length) {\n          // Create the new tableDrag instance. Save in the Drupal variable\n          // to allow other scripts access to the object.\n          Drupal.tableDrag[base] = new Drupal.tableDrag(table[0], settings.tableDrag[base]);\n        }\n      }\n\n      Object.keys(settings.tableDrag || {}).forEach(base => {\n        initTableDrag($(context).find(`#${base}`).once('tabledrag'), base);\n      });\n    }\n\n  };\n  /**\n   * Provides table and field manipulation.\n   *\n   * @constructor\n   *\n   * @param {HTMLElement} table\n   *   DOM object for the table to be made draggable.\n   * @param {object} tableSettings\n   *   Settings for the table added via drupal_add_dragtable().\n   */\n\n  Drupal.tableDrag = function (table, tableSettings) {\n    const self = this;\n    const $table = $(table);\n    /**\n     * @type {jQuery}\n     */\n\n    this.$table = $(table);\n    /**\n     *\n     * @type {HTMLElement}\n     */\n\n    this.table = table;\n    /**\n     * @type {object}\n     */\n\n    this.tableSettings = tableSettings;\n    /**\n     * Used to hold information about a current drag operation.\n     *\n     * @type {?HTMLElement}\n     */\n\n    this.dragObject = null;\n    /**\n     * Provides operations for row manipulation.\n     *\n     * @type {?HTMLElement}\n     */\n\n    this.rowObject = null;\n    /**\n     * Remember the previous element.\n     *\n     * @type {?HTMLElement}\n     */\n\n    this.oldRowElement = null;\n    /**\n     * Used to determine up or down direction from last mouse move.\n     *\n     * @type {number}\n     */\n\n    this.oldY = 0;\n    /**\n     * Whether anything in the entire table has changed.\n     *\n     * @type {bool}\n     */\n\n    this.changed = false;\n    /**\n     * Maximum amount of allowed parenting.\n     *\n     * @type {number}\n     */\n\n    this.maxDepth = 0;\n    /**\n     * Direction of the table.\n     *\n     * @type {number}\n     */\n\n    this.rtl = $(this.table).css('direction') === 'rtl' ? -1 : 1;\n    /**\n     *\n     * @type {bool}\n     */\n\n    this.striping = $(this.table).data('striping') === 1;\n    /**\n     * Configure the scroll settings.\n     *\n     * @type {object}\n     *\n     * @prop {number} amount\n     * @prop {number} interval\n     * @prop {number} trigger\n     */\n\n    this.scrollSettings = {\n      amount: 4,\n      interval: 50,\n      trigger: 70\n    };\n    /**\n     *\n     * @type {?number}\n     */\n\n    this.scrollInterval = null;\n    /**\n     *\n     * @type {number}\n     */\n\n    this.scrollY = 0;\n    /**\n     *\n     * @type {number}\n     */\n\n    this.windowHeight = 0;\n    /**\n     * Check this table's settings for parent relationships.\n     *\n     * For efficiency, large sections of code can be skipped if we don't need to\n     * track horizontal movement and indentations.\n     *\n     * @type {bool}\n     */\n\n    this.indentEnabled = false;\n    Object.keys(tableSettings || {}).forEach(group => {\n      Object.keys(tableSettings[group] || {}).forEach(n => {\n        if (tableSettings[group][n].relationship === 'parent') {\n          this.indentEnabled = true;\n        }\n\n        if (tableSettings[group][n].limit > 0) {\n          this.maxDepth = tableSettings[group][n].limit;\n        }\n      });\n    });\n\n    if (this.indentEnabled) {\n      /**\n       * Total width of indents, set in makeDraggable.\n       *\n       * @type {number}\n       */\n      this.indentCount = 1; // Find the width of indentations to measure mouse movements against.\n      // Because the table doesn't need to start with any indentations, we\n      // manually append 2 indentations in the first draggable row, measure\n      // the offset, then remove.\n\n      const indent = Drupal.theme('tableDragIndentation');\n      const testRow = $('<tr/>').addClass('draggable').appendTo(table);\n      const testCell = $('<td/>').appendTo(testRow).prepend(indent).prepend(indent);\n      const $indentation = testCell.find('.js-indentation');\n      /**\n       *\n       * @type {number}\n       */\n\n      this.indentAmount = $indentation.get(1).offsetLeft - $indentation.get(0).offsetLeft;\n      testRow.remove();\n    } // Make each applicable row draggable.\n    // Match immediate children of the parent element to allow nesting.\n\n\n    $table.find('> tr.draggable, > tbody > tr.draggable').each(function () {\n      self.makeDraggable(this);\n    });\n    const buttonClasses = ['tabledrag-toggle-weight', 'ml-auto', 'bg-blue', 'appearance-none', 'border-2', 'border-blue', 'rounded-lg', 'py-2', 'px-4', 'text-white', 'leading-tight', 'focus:outline-none', 'focus:bg-blue-dark', 'focus:border-blue-dark']; // Add a link before the table for users to show or hide weight columns.\n\n    $table.before($(`<button type=\"button\" class=\"${buttonClasses.join(' ')}\"></button>`).attr('title', Drupal.t('Re-order rows by numerical weight instead of dragging.')).on('click', $.proxy(function (e) {\n      e.preventDefault();\n      this.toggleColumns();\n    }, this)).wrap('<div class=\"flex flex-column items-end mb-3\"></div>').parent()); // Initialize the specified columns (for example, weight or parent columns)\n    // to show or hide according to user preference. This aids accessibility\n    // so that, e.g., screen reader users can choose to enter weight values and\n    // manipulate form elements directly, rather than using drag-and-drop..\n\n    self.initColumns(); // Add event bindings to the document. The self variable is passed along\n    // as event handlers do not have direct access to the tableDrag object.\n\n    $(document).on('touchmove', event => self.dragRow(event.originalEvent.touches[0], self));\n    $(document).on('touchend', event => self.dropRow(event.originalEvent.touches[0], self));\n    $(document).on('mousemove pointermove', event => self.dragRow(event, self));\n    $(document).on('mouseup pointerup', event => self.dropRow(event, self)); // React to localStorage event showing or hiding weight columns.\n\n    $(window).on('storage', $.proxy(function (e) {\n      // Only react to 'Drupal.tableDrag.showWeight' value change.\n      if (e.originalEvent.key === 'Drupal.tableDrag.showWeight') {\n        // This was changed in another window, get the new value for this\n        // window.\n        showWeight = JSON.parse(e.originalEvent.newValue);\n        this.displayColumns(showWeight);\n      }\n    }, this));\n  };\n  /**\n   * Initialize columns containing form elements to be hidden by default.\n   *\n   * Identify and mark each cell with a CSS class so we can easily toggle\n   * show/hide it. Finally, hide columns if user does not have a\n   * 'Drupal.tableDrag.showWeight' localStorage value.\n   */\n\n\n  Drupal.tableDrag.prototype.initColumns = function () {\n    const $table = this.$table;\n    let hidden;\n    let cell;\n    let columnIndex;\n    Object.keys(this.tableSettings || {}).forEach(group => {\n      // Find the first field in this group.\n      Object.keys(this.tableSettings[group]).some(tableSetting => {\n        const field = $table.find(`.${this.tableSettings[group][tableSetting].target}`).eq(0);\n\n        if (field.length && this.tableSettings[group][tableSetting].hidden) {\n          hidden = this.tableSettings[group][tableSetting].hidden;\n          cell = field.closest('td');\n          return true;\n        }\n\n        return false;\n      }); // Mark the column containing this field so it can be hidden.\n\n      if (hidden && cell[0]) {\n        // Add 1 to our indexes. The nth-child selector is 1 based, not 0\n        // based. Match immediate children of the parent element to allow\n        // nesting.\n        columnIndex = cell.parent().find('> td').index(cell.get(0)) + 1;\n        $table.find('> thead > tr, > tbody > tr, > tr').each(this.addColspanClass(columnIndex));\n      }\n    });\n    this.displayColumns(showWeight);\n  };\n  /**\n   * Mark cells that have colspan.\n   *\n   * In order to adjust the colspan instead of hiding them altogether.\n   *\n   * @param {number} columnIndex\n   *   The column index to add colspan class to.\n   *\n   * @return {function}\n   *   Function to add colspan class.\n   */\n\n\n  Drupal.tableDrag.prototype.addColspanClass = function (columnIndex) {\n    return function () {\n      // Get the columnIndex and adjust for any colspans in this row.\n      const $row = $(this);\n      let index = columnIndex;\n      const cells = $row.children();\n      let cell;\n      cells.each(function (n) {\n        if (n < index && this.colSpan && this.colSpan > 1) {\n          index -= this.colSpan - 1;\n        }\n      });\n\n      if (index > 0) {\n        cell = cells.filter(`:nth-child(${index})`);\n\n        if (cell[0].colSpan && cell[0].colSpan > 1) {\n          // If this cell has a colspan, mark it so we can reduce the colspan.\n          cell.addClass('tabledrag-has-colspan');\n        } else {\n          // Mark this cell so we can hide it.\n          cell.addClass('tabledrag-hide');\n        }\n      }\n    };\n  };\n  /**\n   * Hide or display weight columns. Triggers an event on change.\n   *\n   * @fires event:columnschange\n   *\n   * @param {bool} displayWeight\n   *   'true' will show weight columns.\n   */\n\n\n  Drupal.tableDrag.prototype.displayColumns = function (displayWeight) {\n    if (displayWeight) {\n      this.showColumns();\n    } // Default action is to hide columns.\n    else {\n        this.hideColumns();\n      } // Trigger an event to allow other scripts to react to this display change.\n    // Force the extra parameter as a bool.\n\n\n    $('table').findOnce('tabledrag').trigger('columnschange', !!displayWeight);\n  };\n  /**\n   * Toggle the weight column depending on 'showWeight' value.\n   *\n   * Store only default override.\n   */\n\n\n  Drupal.tableDrag.prototype.toggleColumns = function () {\n    showWeight = !showWeight;\n    this.displayColumns(showWeight);\n\n    if (showWeight) {\n      // Save default override.\n      localStorage.setItem('Drupal.tableDrag.showWeight', showWeight);\n    } else {\n      // Reset the value to its default.\n      localStorage.removeItem('Drupal.tableDrag.showWeight');\n    }\n  };\n  /**\n   * Hide the columns containing weight/parent form elements.\n   *\n   * Undo showColumns().\n   */\n\n\n  Drupal.tableDrag.prototype.hideColumns = function () {\n    const $tables = $('table').findOnce('tabledrag'); // Hide weight/parent cells and headers.\n\n    $tables.find('.tabledrag-hide').css('display', 'none'); // Show TableDrag handles.\n\n    $tables.find('.tabledrag-handle').css('display', ''); // Reduce the colspan of any effected multi-span columns.\n\n    $tables.find('.tabledrag-has-colspan').each(function () {\n      this.colSpan = this.colSpan - 1;\n    }); // Change link text.\n\n    $('.tabledrag-toggle-weight').text(Drupal.t('Show row weights'));\n  };\n  /**\n   * Show the columns containing weight/parent form elements.\n   *\n   * Undo hideColumns().\n   */\n\n\n  Drupal.tableDrag.prototype.showColumns = function () {\n    const $tables = $('table').findOnce('tabledrag'); // Show weight/parent cells and headers.\n\n    $tables.find('.tabledrag-hide').css('display', ''); // Hide TableDrag handles.\n\n    $tables.find('.tabledrag-handle').css('display', 'none'); // Increase the colspan for any columns where it was previously reduced.\n\n    $tables.find('.tabledrag-has-colspan').each(function () {\n      this.colSpan = this.colSpan + 1;\n    }); // Change link text.\n\n    $('.tabledrag-toggle-weight').text(Drupal.t('Hide row weights'));\n  };\n  /**\n   * Find the target used within a particular row and group.\n   *\n   * @param {string} group\n   *   Group selector.\n   * @param {HTMLElement} row\n   *   The row HTML element.\n   *\n   * @return {object}\n   *   The table row settings.\n   */\n\n\n  Drupal.tableDrag.prototype.rowSettings = function (group, row) {\n    const field = $(row).find(`.${group}`);\n    const tableSettingsGroup = this.tableSettings[group];\n    return Object.keys(tableSettingsGroup).map(delta => {\n      const targetClass = tableSettingsGroup[delta].target;\n      let rowSettings;\n\n      if (field.is(`.${targetClass}`)) {\n        // Return a copy of the row settings.\n        rowSettings = {};\n        Object.keys(tableSettingsGroup[delta]).forEach(n => {\n          rowSettings[n] = tableSettingsGroup[delta][n];\n        });\n      }\n\n      return rowSettings;\n    }).filter(rowSetting => rowSetting)[0];\n  };\n  /**\n   * Take an item and add event handlers to make it become draggable.\n   *\n   * @param {HTMLElement} item\n   *   The item to add event handlers to.\n   */\n\n\n  Drupal.tableDrag.prototype.makeDraggable = function (item) {\n    const self = this;\n    const $item = $(item); // Add a class to the title link.\n\n    $item.find('td:first-of-type').find('a').addClass('menu-item__link'); // Create the handle.\n\n    const handleClasses = ['tabledrag-handle', 'handle', 'cursor-move', 'align-middle', 'h-4', 'w-4', 'mr-3'];\n    const handle = $(`<span class=\"${handleClasses.join(' ')}\">${_icons_move_svg__WEBPACK_IMPORTED_MODULE_0___default.a}</span>`).attr('title', Drupal.t('Drag to re-order')); // Insert the handle after indentations (if any).\n\n    const $indentationLast = $item.find('td:first-of-type').find('.js-indentation').eq(-1);\n\n    if ($indentationLast.length) {\n      $indentationLast.after(handle); // Update the total width of indentation in this entire table.\n\n      self.indentCount = Math.max($item.find('.js-indentation').length, self.indentCount);\n    } else {\n      $item.find('td').eq(0).prepend(handle);\n    }\n\n    handle.on('mousedown touchstart pointerdown', event => {\n      event.preventDefault();\n\n      if (event.originalEvent.type === 'touchstart') {\n        event = event.originalEvent.touches[0];\n      }\n\n      self.dragStart(event, self, item);\n    }); // Prevent the anchor tag from jumping us to the top of the page.\n\n    handle.on('click', e => {\n      e.preventDefault();\n    }); // Set blur cleanup when a handle is focused.\n\n    handle.on('focus', () => {\n      self.safeBlur = true;\n    }); // On blur, fire the same function as a touchend/mouseup. This is used to\n    // update values after a row has been moved through the keyboard support.\n\n    handle.on('blur', event => {\n      if (self.rowObject && self.safeBlur) {\n        self.dropRow(event, self);\n      }\n    }); // Add arrow-key support to the handle.\n\n    handle.on('keydown', event => {\n      // If a rowObject doesn't yet exist and this isn't the tab key.\n      if (event.keyCode !== 9 && !self.rowObject) {\n        self.rowObject = new self.row(item, 'keyboard', self.indentEnabled, self.maxDepth, true);\n      }\n\n      let keyChange = false;\n      let groupHeight;\n      /* eslint-disable no-fallthrough */\n\n      switch (event.keyCode) {\n        // Left arrow.\n        case 37: // Safari left arrow.\n\n        case 63234:\n          keyChange = true;\n          self.rowObject.indent(-1 * self.rtl);\n          break;\n        // Up arrow.\n\n        case 38: // Safari up arrow.\n\n        case 63232:\n          {\n            let $previousRow = $(self.rowObject.element).prev('tr:first-of-type');\n            let previousRow = $previousRow.get(0);\n\n            while (previousRow && $previousRow.is(':hidden')) {\n              $previousRow = $(previousRow).prev('tr:first-of-type');\n              previousRow = $previousRow.get(0);\n            }\n\n            if (previousRow) {\n              // Do not allow the onBlur cleanup.\n              self.safeBlur = false;\n              self.rowObject.direction = 'up';\n              keyChange = true;\n\n              if ($(item).is('.tabledrag-root')) {\n                // Swap with the previous top-level row.\n                groupHeight = 0;\n\n                while (previousRow && $previousRow.find('.js-indentation').length) {\n                  $previousRow = $(previousRow).prev('tr:first-of-type');\n                  previousRow = $previousRow.get(0);\n                  groupHeight += $previousRow.is(':hidden') ? 0 : previousRow.offsetHeight;\n                }\n\n                if (previousRow) {\n                  self.rowObject.swap('before', previousRow); // No need to check for indentation, 0 is the only valid one.\n\n                  window.scrollBy(0, -groupHeight);\n                }\n              } else if (self.table.tBodies[0].rows[0] !== previousRow || $previousRow.is('.draggable')) {\n                // Swap with the previous row (unless previous row is the first\n                // one and undraggable).\n                self.rowObject.swap('before', previousRow);\n                self.rowObject.interval = null;\n                self.rowObject.indent(0);\n                window.scrollBy(0, -parseInt(item.offsetHeight, 10));\n              } // Regain focus after the DOM manipulation.\n\n\n              handle.trigger('focus');\n            }\n\n            break;\n          }\n        // Right arrow.\n\n        case 39: // Safari right arrow.\n\n        case 63235:\n          keyChange = true;\n          self.rowObject.indent(self.rtl);\n          break;\n        // Down arrow.\n\n        case 40: // Safari down arrow.\n\n        case 63233:\n          {\n            let $nextRow = $(self.rowObject.group).eq(-1).next('tr:first-of-type');\n            let nextRow = $nextRow.get(0);\n\n            while (nextRow && $nextRow.is(':hidden')) {\n              $nextRow = $(nextRow).next('tr:first-of-type');\n              nextRow = $nextRow.get(0);\n            }\n\n            if (nextRow) {\n              // Do not allow the onBlur cleanup.\n              self.safeBlur = false;\n              self.rowObject.direction = 'down';\n              keyChange = true;\n\n              if ($(item).is('.tabledrag-root')) {\n                // Swap with the next group (necessarily a top-level one).\n                groupHeight = 0;\n                const nextGroup = new self.row(nextRow, 'keyboard', self.indentEnabled, self.maxDepth, false);\n\n                if (nextGroup) {\n                  $(nextGroup.group).each(function () {\n                    groupHeight += $(this).is(':hidden') ? 0 : this.offsetHeight;\n                  });\n                  const nextGroupRow = $(nextGroup.group).eq(-1).get(0);\n                  self.rowObject.swap('after', nextGroupRow); // No need to check for indentation, 0 is the only valid one.\n\n                  window.scrollBy(0, parseInt(groupHeight, 10));\n                }\n              } else {\n                // Swap with the next row.\n                self.rowObject.swap('after', nextRow);\n                self.rowObject.interval = null;\n                self.rowObject.indent(0);\n                window.scrollBy(0, parseInt(item.offsetHeight, 10));\n              } // Regain focus after the DOM manipulation.\n\n\n              handle.trigger('focus');\n            }\n\n            break;\n          }\n      }\n      /* eslint-enable no-fallthrough */\n\n\n      if (self.rowObject && self.rowObject.changed === true) {\n        $(item).addClass('drag');\n\n        if (self.oldRowElement) {\n          $(self.oldRowElement).removeClass('drag-previous');\n        }\n\n        self.oldRowElement = item;\n\n        if (self.striping === true) {\n          self.restripeTable();\n        }\n\n        self.onDrag();\n      } // Returning false if we have an arrow key to prevent scrolling.\n\n\n      if (keyChange) {\n        return false;\n      }\n    }); // Compatibility addition, return false on keypress to prevent unwanted\n    // scrolling. IE and Safari will suppress scrolling on keydown, but all\n    // other browsers need to return false on keypress.\n    // http://www.quirksmode.org/js/keys.html\n\n    handle.on('keypress', event => {\n      /* eslint-disable no-fallthrough */\n      switch (event.keyCode) {\n        // Left arrow.\n        case 37: // Up arrow.\n\n        case 38: // Right arrow.\n\n        case 39: // Down arrow.\n\n        case 40:\n          return false;\n      }\n      /* eslint-enable no-fallthrough */\n\n    });\n  };\n  /**\n   * Pointer event initiator, creates drag object and information.\n   *\n   * @param {jQuery.Event} event\n   *   The event object that trigger the drag.\n   * @param {Drupal.tableDrag} self\n   *   The drag handle.\n   * @param {HTMLElement} item\n   *   The item that that is being dragged.\n   */\n\n\n  Drupal.tableDrag.prototype.dragStart = function (event, self, item) {\n    // Create a new dragObject recording the pointer information.\n    self.dragObject = {};\n    self.dragObject.initOffset = self.getPointerOffset(item, event);\n    self.dragObject.initPointerCoords = self.pointerCoords(event);\n\n    if (self.indentEnabled) {\n      self.dragObject.indentPointerPos = self.dragObject.initPointerCoords;\n    } // If there's a lingering row object from the keyboard, remove its focus.\n\n\n    if (self.rowObject) {\n      $(self.rowObject.element).find('a.tabledrag-handle').trigger('blur');\n    } // Create a new rowObject for manipulation of this row.\n\n\n    self.rowObject = new self.row(item, 'pointer', self.indentEnabled, self.maxDepth, true); // Save the position of the table.\n\n    self.table.topY = $(self.table).offset().top;\n    self.table.bottomY = self.table.topY + self.table.offsetHeight; // Add classes to the handle and row.\n\n    $(item).addClass('drag'); // Set the document to use the move cursor during drag.\n\n    $('body').addClass('drag');\n\n    if (self.oldRowElement) {\n      $(self.oldRowElement).removeClass('drag-previous');\n    }\n  };\n  /**\n   * Pointer movement handler, bound to document.\n   *\n   * @param {jQuery.Event} event\n   *   The pointer event.\n   * @param {Drupal.tableDrag} self\n   *   The tableDrag instance.\n   *\n   * @return {bool|undefined}\n   *   Undefined if no dragObject is defined, false otherwise.\n   */\n\n\n  Drupal.tableDrag.prototype.dragRow = function (event, self) {\n    if (self.dragObject) {\n      self.currentPointerCoords = self.pointerCoords(event);\n      const y = self.currentPointerCoords.y - self.dragObject.initOffset.y;\n      const x = self.currentPointerCoords.x - self.dragObject.initOffset.x; // Check for row swapping and vertical scrolling.\n\n      if (y !== self.oldY) {\n        self.rowObject.direction = y > self.oldY ? 'down' : 'up'; // Update the old value.\n\n        self.oldY = y; // Check if the window should be scrolled (and how fast).\n\n        const scrollAmount = self.checkScroll(self.currentPointerCoords.y); // Stop any current scrolling.\n\n        clearInterval(self.scrollInterval); // Continue scrolling if the mouse has moved in the scroll direction.\n\n        if (scrollAmount > 0 && self.rowObject.direction === 'down' || scrollAmount < 0 && self.rowObject.direction === 'up') {\n          self.setScroll(scrollAmount);\n        } // If we have a valid target, perform the swap and restripe the table.\n\n\n        const currentRow = self.findDropTargetRow(x, y);\n\n        if (currentRow) {\n          if (self.rowObject.direction === 'down') {\n            self.rowObject.swap('after', currentRow, self);\n          } else {\n            self.rowObject.swap('before', currentRow, self);\n          }\n\n          if (self.striping === true) {\n            self.restripeTable();\n          }\n        }\n      } // Similar to row swapping, handle indentations.\n\n\n      if (self.indentEnabled) {\n        const xDiff = self.currentPointerCoords.x - self.dragObject.indentPointerPos.x; // Set the number of indentations the pointer has been moved left or\n        // right.\n\n        const indentDiff = Math.round(xDiff / self.indentAmount); // Indent the row with our estimated diff, which may be further\n        // restricted according to the rows around this row.\n\n        const indentChange = self.rowObject.indent(indentDiff); // Update table and pointer indentations.\n\n        self.dragObject.indentPointerPos.x += self.indentAmount * indentChange * self.rtl;\n        self.indentCount = Math.max(self.indentCount, self.rowObject.indents);\n      }\n\n      return false;\n    }\n  };\n  /**\n   * Pointerup behavior.\n   *\n   * @param {jQuery.Event} event\n   *   The pointer event.\n   * @param {Drupal.tableDrag} self\n   *   The tableDrag instance.\n   */\n\n\n  Drupal.tableDrag.prototype.dropRow = function (event, self) {\n    let droppedRow;\n    let $droppedRow; // Drop row functionality.\n\n    if (self.rowObject !== null) {\n      droppedRow = self.rowObject.element;\n      $droppedRow = $(droppedRow); // The row is already in the right place so we just release it.\n\n      if (self.rowObject.changed === true) {\n        // Update the fields in the dropped row.\n        self.updateFields(droppedRow); // If a setting exists for affecting the entire group, update all the\n        // fields in the entire dragged group.\n\n        Object.keys(self.tableSettings || {}).forEach(group => {\n          const rowSettings = self.rowSettings(group, droppedRow);\n\n          if (rowSettings.relationship === 'group') {\n            Object.keys(self.rowObject.children || {}).forEach(n => {\n              self.updateField(self.rowObject.children[n], group);\n            });\n          }\n        });\n        self.rowObject.markChanged();\n\n        if (self.changed === false) {\n          $(Drupal.theme('tableDragChangedWarning')).insertBefore(self.table).hide().fadeIn('slow');\n          self.changed = true;\n        }\n      }\n\n      if (self.indentEnabled) {\n        self.rowObject.removeIndentClasses();\n      }\n\n      if (self.oldRowElement) {\n        $(self.oldRowElement).removeClass('drag-previous');\n      }\n\n      $droppedRow.removeClass('drag').addClass('drag-previous');\n      self.oldRowElement = droppedRow;\n      self.onDrop();\n      self.rowObject = null;\n    } // Functionality specific only to pointerup events.\n\n\n    if (self.dragObject !== null) {\n      self.dragObject = null;\n      $('body').removeClass('drag');\n      clearInterval(self.scrollInterval);\n    }\n  };\n  /**\n   * Get the coordinates from the event (allowing for browser differences).\n   *\n   * @param {jQuery.Event} event\n   *   The pointer event.\n   *\n   * @return {object}\n   *   An object with `x` and `y` keys indicating the position.\n   */\n\n\n  Drupal.tableDrag.prototype.pointerCoords = function (event) {\n    if (event.pageX || event.pageY) {\n      return {\n        x: event.pageX,\n        y: event.pageY\n      };\n    }\n\n    return {\n      x: event.clientX + document.body.scrollLeft - document.body.clientLeft,\n      y: event.clientY + document.body.scrollTop - document.body.clientTop\n    };\n  };\n  /**\n   * Get the event offset from the target element.\n   *\n   * Given a target element and a pointer event, get the event offset from that\n   * element. To do this we need the element's position and the target position.\n   *\n   * @param {HTMLElement} target\n   *   The target HTML element.\n   * @param {jQuery.Event} event\n   *   The pointer event.\n   *\n   * @return {object}\n   *   An object with `x` and `y` keys indicating the position.\n   */\n\n\n  Drupal.tableDrag.prototype.getPointerOffset = function (target, event) {\n    const docPos = $(target).offset();\n    const pointerPos = this.pointerCoords(event);\n    return {\n      x: pointerPos.x - docPos.left,\n      y: pointerPos.y - docPos.top\n    };\n  };\n  /**\n   * Find the row the mouse is currently over.\n   *\n   * This row is then taken and swapped with the one being dragged.\n   *\n   * @param {number} x\n   *   The x coordinate of the mouse on the page (not the screen).\n   * @param {number} y\n   *   The y coordinate of the mouse on the page (not the screen).\n   *\n   * @return {*}\n   *   The drop target row, if found.\n   */\n\n\n  Drupal.tableDrag.prototype.findDropTargetRow = function (x, y) {\n    const rows = $(this.table.tBodies[0].rows).not(':hidden');\n\n    for (let n = 0; n < rows.length; n++) {\n      let row = rows[n];\n      let $row = $(row);\n      const rowY = $row.offset().top;\n      let rowHeight; // Because Safari does not report offsetHeight on table rows, but does on\n      // table cells, grab the firstChild of the row and use that instead.\n      // http://jacob.peargrove.com/blog/2006/technical/table-row-offsettop-bug-in-safari.\n\n      if (row.offsetHeight === 0) {\n        rowHeight = parseInt(row.firstChild.offsetHeight, 10) / 2;\n      } // Other browsers.\n      else {\n          rowHeight = parseInt(row.offsetHeight, 10) / 2;\n        } // Because we always insert before, we need to offset the height a bit.\n\n\n      if (y > rowY - rowHeight && y < rowY + rowHeight) {\n        if (this.indentEnabled) {\n          // Check that this row is not a child of the row being dragged.\n          if (Object.keys(this.rowObject.group).some(o => this.rowObject.group[o] === row)) {\n            return null;\n          }\n        } // Do not allow a row to be swapped with itself.\n        else if (row === this.rowObject.element) {\n            return null;\n          } // Check that swapping with this row is allowed.\n\n\n        if (!this.rowObject.isValidSwap(row)) {\n          return null;\n        } // We may have found the row the mouse just passed over, but it doesn't\n        // take into account hidden rows. Skip backwards until we find a\n        // draggable row.\n\n\n        while ($row.is(':hidden') && $row.prev('tr').is(':hidden')) {\n          $row = $row.prev('tr:first-of-type');\n          row = $row.get(0);\n        }\n\n        return row;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * After the row is dropped, update the table fields.\n   *\n   * @param {HTMLElement} changedRow\n   *   DOM object for the row that was just dropped.\n   */\n\n\n  Drupal.tableDrag.prototype.updateFields = function (changedRow) {\n    Object.keys(this.tableSettings || {}).forEach(group => {\n      // Each group may have a different setting for relationship, so we find\n      // the source rows for each separately.\n      this.updateField(changedRow, group);\n    });\n  };\n  /**\n   * After the row is dropped, update a single table field.\n   *\n   * @param {HTMLElement} changedRow\n   *   DOM object for the row that was just dropped.\n   * @param {string} group\n   *   The settings group on which field updates will occur.\n   */\n\n\n  Drupal.tableDrag.prototype.updateField = function (changedRow, group) {\n    let rowSettings = this.rowSettings(group, changedRow);\n    const $changedRow = $(changedRow);\n    let sourceRow;\n    let $previousRow;\n    let previousRow;\n    let useSibling; // Set the row as its own target.\n\n    if (rowSettings.relationship === 'self' || rowSettings.relationship === 'group') {\n      sourceRow = changedRow;\n    } // Siblings are easy, check previous and next rows.\n    else if (rowSettings.relationship === 'sibling') {\n        $previousRow = $changedRow.prev('tr:first-of-type');\n        previousRow = $previousRow.get(0);\n        const $nextRow = $changedRow.next('tr:first-of-type');\n        const nextRow = $nextRow.get(0);\n        sourceRow = changedRow;\n\n        if ($previousRow.is('.draggable') && $previousRow.find(`.${group}`).length) {\n          if (this.indentEnabled) {\n            if ($previousRow.find('.js-indentations').length === $changedRow.find('.js-indentations').length) {\n              sourceRow = previousRow;\n            }\n          } else {\n            sourceRow = previousRow;\n          }\n        } else if ($nextRow.is('.draggable') && $nextRow.find(`.${group}`).length) {\n          if (this.indentEnabled) {\n            if ($nextRow.find('.js-indentations').length === $changedRow.find('.js-indentations').length) {\n              sourceRow = nextRow;\n            }\n          } else {\n            sourceRow = nextRow;\n          }\n        }\n      } // Parents, look up the tree until we find a field not in this group.\n      // Go up as many parents as indentations in the changed row.\n      else if (rowSettings.relationship === 'parent') {\n          $previousRow = $changedRow.prev('tr');\n          previousRow = $previousRow;\n\n          while ($previousRow.length && $previousRow.find('.js-indentation').length >= this.rowObject.indents) {\n            $previousRow = $previousRow.prev('tr');\n            previousRow = $previousRow;\n          } // If we found a row.\n\n\n          if ($previousRow.length) {\n            sourceRow = $previousRow.get(0);\n          } // Otherwise we went all the way to the left of the table without finding\n          // a parent, meaning this item has been placed at the root level.\n          else {\n              // Use the first row in the table as source, because it's guaranteed to\n              // be at the root level. Find the first item, then compare this row\n              // against it as a sibling.\n              sourceRow = $(this.table).find('tr.draggable:first-of-type').get(0);\n\n              if (sourceRow === this.rowObject.element) {\n                sourceRow = $(this.rowObject.group[this.rowObject.group.length - 1]).next('tr.draggable').get(0);\n              }\n\n              useSibling = true;\n            }\n        } // Because we may have moved the row from one category to another,\n    // take a look at our sibling and borrow its sources and targets.\n\n\n    this.copyDragClasses(sourceRow, changedRow, group);\n    rowSettings = this.rowSettings(group, changedRow); // In the case that we're looking for a parent, but the row is at the top\n    // of the tree, copy our sibling's values.\n\n    if (useSibling) {\n      rowSettings.relationship = 'sibling';\n      rowSettings.source = rowSettings.target;\n    }\n\n    const targetClass = `.${rowSettings.target}`;\n    const targetElement = $changedRow.find(targetClass).get(0); // Check if a target element exists in this row.\n\n    if (targetElement) {\n      const sourceClass = `.${rowSettings.source}`;\n      const sourceElement = $(sourceClass, sourceRow).get(0);\n\n      switch (rowSettings.action) {\n        case 'depth':\n          // Get the depth of the target row.\n          targetElement.value = $(sourceElement).closest('tr').find('.js-indentation').length;\n          break;\n\n        case 'match':\n          // Update the value.\n          targetElement.value = sourceElement.value;\n          break;\n\n        case 'order':\n          {\n            const siblings = this.rowObject.findSiblings(rowSettings);\n\n            if ($(targetElement).is('select')) {\n              // Get a list of acceptable values.\n              const values = [];\n              $(targetElement).find('option').each(function () {\n                values.push(this.value);\n              });\n              const maxVal = values[values.length - 1]; // Populate the values in the siblings.\n\n              $(siblings).find(targetClass).each(function () {\n                // If there are more items than possible values, assign the\n                // maximum value to the row.\n                if (values.length > 0) {\n                  this.value = values.shift();\n                } else {\n                  this.value = maxVal;\n                }\n              });\n            } else {\n              // Assume a numeric input field.\n              let weight = parseInt($(siblings[0]).find(targetClass).val(), 10) || 0;\n              $(siblings).find(targetClass).each(function () {\n                this.value = weight;\n                weight++;\n              });\n            }\n\n            break;\n          }\n      }\n    }\n  };\n  /**\n   * Copy all tableDrag related classes from one row to another.\n   *\n   * Copy all special tableDrag classes from one row's form elements to a\n   * different one, removing any special classes that the destination row\n   * may have had.\n   *\n   * @param {HTMLElement} sourceRow\n   *   The element for the source row.\n   * @param {HTMLElement} targetRow\n   *   The element for the target row.\n   * @param {string} group\n   *   The group selector.\n   */\n\n\n  Drupal.tableDrag.prototype.copyDragClasses = function (sourceRow, targetRow, group) {\n    const sourceElement = $(sourceRow).find(`.${group}`);\n    const targetElement = $(targetRow).find(`.${group}`);\n\n    if (sourceElement.length && targetElement.length) {\n      targetElement[0].className = sourceElement[0].className;\n    }\n  };\n  /**\n   * Check the suggested scroll of the table.\n   *\n   * @param {number} cursorY\n   *   The Y position of the cursor.\n   *\n   * @return {number}\n   *   The suggested scroll.\n   */\n\n\n  Drupal.tableDrag.prototype.checkScroll = function (cursorY) {\n    const de = document.documentElement;\n    const b = document.body;\n    const windowHeight = window.innerHeight || (de.clientHeight && de.clientWidth !== 0 ? de.clientHeight : b.offsetHeight);\n    this.windowHeight = windowHeight;\n    let scrollY;\n\n    if (document.all) {\n      scrollY = !de.scrollTop ? b.scrollTop : de.scrollTop;\n    } else {\n      scrollY = window.pageYOffset ? window.pageYOffset : window.scrollY;\n    }\n\n    this.scrollY = scrollY;\n    const trigger = this.scrollSettings.trigger;\n    let delta = 0; // Return a scroll speed relative to the edge of the screen.\n\n    if (cursorY - scrollY > windowHeight - trigger) {\n      delta = trigger / (windowHeight + scrollY - cursorY);\n      delta = delta > 0 && delta < trigger ? delta : trigger;\n      return delta * this.scrollSettings.amount;\n    }\n\n    if (cursorY - scrollY < trigger) {\n      delta = trigger / (cursorY - scrollY);\n      delta = delta > 0 && delta < trigger ? delta : trigger;\n      return -delta * this.scrollSettings.amount;\n    }\n  };\n  /**\n   * Set the scroll for the table.\n   *\n   * @param {number} scrollAmount\n   *   The amount of scroll to apply to the window.\n   */\n\n\n  Drupal.tableDrag.prototype.setScroll = function (scrollAmount) {\n    const self = this;\n    this.scrollInterval = setInterval(() => {\n      // Update the scroll values stored in the object.\n      self.checkScroll(self.currentPointerCoords.y);\n      const aboveTable = self.scrollY > self.table.topY;\n      const belowTable = self.scrollY + self.windowHeight < self.table.bottomY;\n\n      if (scrollAmount > 0 && belowTable || scrollAmount < 0 && aboveTable) {\n        window.scrollBy(0, scrollAmount);\n      }\n    }, this.scrollSettings.interval);\n  };\n  /**\n   * Command to restripe table properly.\n   */\n\n\n  Drupal.tableDrag.prototype.restripeTable = function () {\n    // :even and :odd are reversed because jQuery counts from 0 and\n    // we count from 1, so we're out of sync.\n    // Match immediate children of the parent element to allow nesting.\n    $(this.table).find('> tbody > tr.draggable, > tr.draggable').filter(':visible').filter(':odd').removeClass('odd').addClass('even').end().filter(':even').removeClass('even').addClass('odd');\n  };\n  /**\n   * Stub function. Allows a custom handler when a row begins dragging.\n   *\n   * @return {null}\n   *   Returns null when the stub function is used.\n   */\n\n\n  Drupal.tableDrag.prototype.onDrag = function () {\n    return null;\n  };\n  /**\n   * Stub function. Allows a custom handler when a row is dropped.\n   *\n   * @return {null}\n   *   Returns null when the stub function is used.\n   */\n\n\n  Drupal.tableDrag.prototype.onDrop = function () {\n    return null;\n  };\n  /**\n   * Constructor to make a new object to manipulate a table row.\n   *\n   * @param {HTMLElement} tableRow\n   *   The DOM element for the table row we will be manipulating.\n   * @param {string} method\n   *   The method in which this row is being moved. Either 'keyboard' or\n   *   'mouse'.\n   * @param {bool} indentEnabled\n   *   Whether the containing table uses indentations. Used for optimizations.\n   * @param {number} maxDepth\n   *   The maximum amount of indentations this row may contain.\n   * @param {bool} addClasses\n   *   Whether we want to add classes to this row to indicate child\n   *   relationships.\n   */\n\n\n  Drupal.tableDrag.prototype.row = function (tableRow, method, indentEnabled, maxDepth, addClasses) {\n    const $tableRow = $(tableRow);\n    this.element = tableRow;\n    this.method = method;\n    this.group = [tableRow];\n    this.groupDepth = $tableRow.find('.js-indentation').length;\n    this.changed = false;\n    this.table = $tableRow.closest('table')[0];\n    this.indentEnabled = indentEnabled;\n    this.maxDepth = maxDepth; // Direction the row is being moved.\n\n    this.direction = '';\n\n    if (this.indentEnabled) {\n      this.indents = $tableRow.find('.js-indentation').length;\n      this.children = this.findChildren(addClasses);\n      this.group = $.merge(this.group, this.children); // Find the depth of this entire group.\n\n      for (let n = 0; n < this.group.length; n++) {\n        this.groupDepth = Math.max($(this.group[n]).find('.js-indentation').length, this.groupDepth);\n      }\n    }\n  };\n  /**\n   * Find all children of rowObject by indentation.\n   *\n   * @param {bool} addClasses\n   *   Whether we want to add classes to this row to indicate child\n   *   relationships.\n   *\n   * @return {Array}\n   *   An array of children of the row.\n   */\n\n\n  Drupal.tableDrag.prototype.row.prototype.findChildren = function (addClasses) {\n    const parentIndentation = this.indents;\n    let currentRow = $(this.element, this.table).next('tr.draggable');\n    const rows = [];\n    let child = 0;\n\n    function rowIndentation(indentNum, el) {\n      const self = $(el);\n\n      if (child === 1 && indentNum === parentIndentation) {\n        self.addClass('tree-child-first');\n      }\n\n      if (indentNum === parentIndentation) {\n        self.addClass('tree-child');\n      } else if (indentNum > parentIndentation) {\n        self.addClass('tree-child-horizontal');\n      }\n    }\n\n    while (currentRow.length) {\n      // A greater indentation indicates this is a child.\n      if (currentRow.find('.js-indentation').length > parentIndentation) {\n        child++;\n        rows.push(currentRow[0]);\n\n        if (addClasses) {\n          currentRow.find('.js-indentation').each(rowIndentation);\n        }\n      } else {\n        break;\n      }\n\n      currentRow = currentRow.next('tr.draggable');\n    }\n\n    if (addClasses && rows.length) {\n      $(rows[rows.length - 1]).find(`.js-indentation:nth-child(${parentIndentation + 1})`).addClass('tree-child-last');\n    }\n\n    return rows;\n  };\n  /**\n   * Ensure that two rows are allowed to be swapped.\n   *\n   * @param {HTMLElement} row\n   *   DOM object for the row being considered for swapping.\n   *\n   * @return {bool}\n   *   Whether the swap is a valid swap or not.\n   */\n\n\n  Drupal.tableDrag.prototype.row.prototype.isValidSwap = function (row) {\n    const $row = $(row);\n\n    if (this.indentEnabled) {\n      let prevRow;\n      let nextRow;\n\n      if (this.direction === 'down') {\n        prevRow = row;\n        nextRow = $row.next('tr').get(0);\n      } else {\n        prevRow = $row.prev('tr').get(0);\n        nextRow = row;\n      }\n\n      this.interval = this.validIndentInterval(prevRow, nextRow); // We have an invalid swap if the valid indentations interval is empty.\n\n      if (this.interval.min > this.interval.max) {\n        return false;\n      }\n    } // Do not let an un-draggable first row have anything put before it.\n\n\n    if (this.table.tBodies[0].rows[0] === row && $row.is(':not(.draggable)')) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Perform the swap between two rows.\n   *\n   * @param {string} position\n   *   Whether the swap will occur 'before' or 'after' the given row.\n   * @param {HTMLElement} row\n   *   DOM element what will be swapped with the row group.\n   */\n\n\n  Drupal.tableDrag.prototype.row.prototype.swap = function (position, row) {\n    // Makes sure only DOM object are passed to Drupal.detachBehaviors().\n    this.group.forEach(row => {\n      Drupal.detachBehaviors(row, drupalSettings, 'move');\n    });\n    $(row)[position](this.group); // Makes sure only DOM object are passed to Drupal.attachBehaviors()s.\n\n    this.group.forEach(row => {\n      Drupal.attachBehaviors(row, drupalSettings);\n    });\n    this.changed = true;\n    this.onSwap(row);\n  };\n  /**\n   * Determine the valid indentations interval for the row at a given position.\n   *\n   * @param {?HTMLElement} prevRow\n   *   DOM object for the row before the tested position\n   *   (or null for first position in the table).\n   * @param {?HTMLElement} nextRow\n   *   DOM object for the row after the tested position\n   *   (or null for last position in the table).\n   *\n   * @return {object}\n   *   An object with the keys `min` and `max` to indicate the valid indent\n   *   interval.\n   */\n\n\n  Drupal.tableDrag.prototype.row.prototype.validIndentInterval = function (prevRow, nextRow) {\n    const $prevRow = $(prevRow);\n    let maxIndent; // Minimum indentation:\n    // Do not orphan the next row.\n\n    const minIndent = nextRow ? $(nextRow).find('.js-indentation').length : 0; // Maximum indentation:\n\n    if (!prevRow || $prevRow.is(':not(.draggable)') || $(this.element).is('.tabledrag-root')) {\n      // Do not indent:\n      // - the first row in the table,\n      // - rows dragged below a non-draggable row,\n      // - 'root' rows.\n      maxIndent = 0;\n    } else {\n      // Do not go deeper than as a child of the previous row.\n      maxIndent = $prevRow.find('.js-indentation').length + ($prevRow.is('.tabledrag-leaf') ? 0 : 1); // Limit by the maximum allowed depth for the table.\n\n      if (this.maxDepth) {\n        maxIndent = Math.min(maxIndent, this.maxDepth - (this.groupDepth - this.indents));\n      }\n    }\n\n    return {\n      min: minIndent,\n      max: maxIndent\n    };\n  };\n  /**\n   * Indent a row within the legal bounds of the table.\n   *\n   * @param {number} indentDiff\n   *   The number of additional indentations proposed for the row (can be\n   *   positive or negative). This number will be adjusted to nearest valid\n   *   indentation level for the row.\n   *\n   * @return {number}\n   *   The number of indentations applied.\n   */\n\n\n  Drupal.tableDrag.prototype.row.prototype.indent = function (indentDiff) {\n    const $group = $(this.group); // Determine the valid indentations interval if not available yet.\n\n    if (!this.interval) {\n      const prevRow = $(this.element).prev('tr').get(0);\n      const nextRow = $group.eq(-1).next('tr').get(0);\n      this.interval = this.validIndentInterval(prevRow, nextRow);\n    } // Adjust to the nearest valid indentation.\n\n\n    let indent = this.indents + indentDiff;\n    indent = Math.max(indent, this.interval.min);\n    indent = Math.min(indent, this.interval.max);\n    indentDiff = indent - this.indents;\n\n    for (let n = 1; n <= Math.abs(indentDiff); n++) {\n      // Add or remove indentations.\n      if (indentDiff < 0) {\n        $group.find('.js-indentation:first-of-type').remove();\n        this.indents--;\n      } else {\n        $group.find('td:first-of-type').prepend(Drupal.theme('tableDragIndentation'));\n        this.indents++;\n      }\n    }\n\n    if (indentDiff) {\n      // Update indentation for this row.\n      this.changed = true;\n      this.groupDepth += indentDiff;\n      this.onIndent();\n    }\n\n    return indentDiff;\n  };\n  /**\n   * Find all siblings for a row.\n   *\n   * According to its subgroup or indentation. Note that the passed-in row is\n   * included in the list of siblings.\n   *\n   * @param {object} rowSettings\n   *   The field settings we're using to identify what constitutes a sibling.\n   *\n   * @return {Array}\n   *   An array of siblings.\n   */\n\n\n  Drupal.tableDrag.prototype.row.prototype.findSiblings = function (rowSettings) {\n    const siblings = [];\n    const directions = ['prev', 'next'];\n    const rowIndentation = this.indents;\n    let checkRowIndentation;\n\n    for (let d = 0; d < directions.length; d++) {\n      let checkRow = $(this.element)[directions[d]]();\n\n      while (checkRow.length) {\n        // Check that the sibling contains a similar target field.\n        if (checkRow.find(`.${rowSettings.target}`)) {\n          // Either add immediately if this is a flat table, or check to ensure\n          // that this row has the same level of indentation.\n          if (this.indentEnabled) {\n            checkRowIndentation = checkRow.find('.js-indentation').length;\n          }\n\n          if (!this.indentEnabled || checkRowIndentation === rowIndentation) {\n            siblings.push(checkRow[0]);\n          } else if (checkRowIndentation < rowIndentation) {\n            // No need to keep looking for siblings when we get to a parent.\n            break;\n          }\n        } else {\n          break;\n        }\n\n        checkRow = checkRow[directions[d]]();\n      } // Since siblings are added in reverse order for previous, reverse the\n      // completed list of previous siblings. Add the current row and continue.\n\n\n      if (directions[d] === 'prev') {\n        siblings.reverse();\n        siblings.push(this.element);\n      }\n    }\n\n    return siblings;\n  };\n  /**\n   * Remove indentation helper classes from the current row group.\n   */\n\n\n  Drupal.tableDrag.prototype.row.prototype.removeIndentClasses = function () {\n    Object.keys(this.children || {}).forEach(n => {\n      $(this.children[n]).find('.js-indentation').removeClass('tree-child').removeClass('tree-child-first').removeClass('tree-child-last').removeClass('tree-child-horizontal');\n    });\n  };\n  /**\n   * Add an asterisk or other marker to the changed row.\n   */\n\n\n  Drupal.tableDrag.prototype.row.prototype.markChanged = function () {\n    const marker = Drupal.theme('tableDragChangedMarker');\n    const cell = $(this.element).find('td:first-of-type');\n\n    if (cell.find('.tabledrag-changed').length === 0) {\n      cell.append(marker);\n    }\n  };\n  /**\n   * Stub function. Allows a custom handler when a row is indented.\n   *\n   * @return {null}\n   *   Returns null when the stub function is used.\n   */\n\n\n  Drupal.tableDrag.prototype.row.prototype.onIndent = function () {\n    return null;\n  };\n  /**\n   * Stub function. Allows a custom handler when a row is swapped.\n   *\n   * @param {HTMLElement} swappedRow\n   *   The element for the swapped row.\n   *\n   * @return {null}\n   *   Returns null when the stub function is used.\n   */\n\n\n  Drupal.tableDrag.prototype.row.prototype.onSwap = function (swappedRow) {\n    return null;\n  };\n\n  $.extend(Drupal.theme,\n  /** @lends Drupal.theme */\n  {\n    /**\n     * @return {string}\n     *  Markup for the marker.\n     */\n    tableDragChangedMarker() {\n      const markerClasses = ['tabledrag-changed', 'text-purple-darkest', 'font-bold', 'mr-3'];\n      return `\n        <span title=\"${Drupal.t('Changed')}\" class=\"${markerClasses.join(' ')}\">${_icons_info_svg__WEBPACK_IMPORTED_MODULE_1___default.a}</span>`;\n    },\n\n    /**\n     * @return {string}\n     *   Markup for the indentation.\n     */\n    tableDragIndentation() {\n      return '<div class=\"js-indentation indentation\">&nbsp;</div>';\n    },\n\n    /**\n     * @return {string}\n     *   Markup for the warning.\n     */\n    tableDragChangedWarning() {\n      const warningClasses = [''];\n      return `\n        <div role=\"alert\" class=\"bg-purple-lightest border-t-4 border-purple rounded-b text-purple-darkest px-4 py-3 shadow-md mb-4\">\n          <div class=\"flex\">\n            ${Drupal.theme('tableDragChangedMarker')}\n            <div>\n              ${Drupal.t('You have unsaved changes.')}\n            </div>\n          </div>\n        </div>`;\n      return `<div class=\"bg-indigo-darkest text-center py-4 lg:px-4\">\n          <div class=\"p-2 bg-indigo-darker items-center text-indigo-lightest leading-none lg:rounded-full flex lg:inline-flex\" role=\"alert\">\n            ${Drupal.theme('tableDragChangedMarker')}\n            <span class=\"font-semibold mr-2 text-left flex-auto\">${Drupal.t('You have unsaved changes.')}</span>\n          </div>\n        </div>`;\n    }\n\n  });\n})(jQuery, Drupal, drupalSettings);\n\n//# sourceURL=webpack:///./js/src/tabledrag.es6.js?");

/***/ }),

/***/ "./scss/style.scss":
/*!*************************!*\
  !*** ./scss/style.scss ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin\n\n//# sourceURL=webpack:///./scss/style.scss?");

/***/ }),

/***/ 0:
/*!****************************************************************************************************************************************!*\
  !*** multi ./js/src/cshs.es6.js ./js/src/dropbutton.es6.js ./js/src/simpler-select.es6.js ./js/src/tabledrag.es6.js ./scss/style.scss ***!
  \****************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./js/src/cshs.es6.js */\"./js/src/cshs.es6.js\");\n__webpack_require__(/*! ./js/src/dropbutton.es6.js */\"./js/src/dropbutton.es6.js\");\n__webpack_require__(/*! ./js/src/simpler-select.es6.js */\"./js/src/simpler-select.es6.js\");\n__webpack_require__(/*! ./js/src/tabledrag.es6.js */\"./js/src/tabledrag.es6.js\");\nmodule.exports = __webpack_require__(/*! ./scss/style.scss */\"./scss/style.scss\");\n\n\n//# sourceURL=webpack:///multi_./js/src/cshs.es6.js_./js/src/dropbutton.es6.js_./js/src/simpler-select.es6.js_./js/src/tabledrag.es6.js_./scss/style.scss?");

/***/ })

/******/ });